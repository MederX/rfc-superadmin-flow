# RFC: Суперадминка Telegram WebApp
## Обзор

Цель — добавить в продукт суперадминку, доступную из Telegram по кнопке «Меню», которая открывает Telegram WebApp со списком карточек заведений. Суперадмин может:
- просматривать все заведения и видеть наличие именной ссылки (shop_groups),
- перейти на существующую админ-страницу заведения и выполнять действия владельца (детальный профиль партнера, добавить блюдо, редактировать меню, отчет по заказам),
- вернуться к списку,
- назначить именную ссылку (группу) заведению.


## Цели

Цели:
- Быстрый обзор и управление всеми заведениями из единого интерфейса в Telegram WebApp.
- Переиспользование существующей админки заведения без дублирования логики.
- Введение четкой роли super_admin и разграничение доступа.


## Пользовательские истории
1) Как суперадмин, я открываю «Меню» в Telegram и вижу список карточек заведений с поиском по названию и фильтрами (Активные/С именной ссылкой/Неактивные).
2) Как суперадмин, кликаю карточку заведения и попадаю в текущую админку заведения.
3) Как суперадмин, я редактирую заведение так же, как владелец (профиль, блюда, меню, отчеты).
4) Как суперадмин, я жму «Назад» в WebApp и возвращаюсь к списку заведений.
5) Как суперадмин, я жму «Создать заведение», заполняю форму и вижу новое заведение в списке.
6) Как суперадмин, я жму «Назначить группу» у выбранного заведения и задаю ему именную ссылку (code).

## Детализация флоу

### Флоу 1: «Меню» -> список карточек заведений
UX:
- В Telegram WebApp отображаются карточки заведений: название, отметка «С именной ссылкой», возможно в будущем город
- Поиск по названию (case-insensitive), фильтр: All/С именной ссылкой.
- Пагинация (limit/offset) при большом количестве заведений.

API (новое или расширение существующего):
- GET /v2/superadmin/shops?query={q}&filter={all|named}&limit={n}&offset={n}
  - Требует роль super_admin.
  - Ответ: []ShopCard, где ShopCard включает id, name, groupCode (если есть).

Используемые данные и источники:
- Именная ссылка: наличие записи в shop_groups с shop_id в массиве shop_ids; получение code через rdb.GetCodeByShopID.

Ошибки:
- 401/403 при отсутствии роли super_admin.
- 400 при некорректных параметрах пагинации.
- Пустой список — корректный 200 с [].


### Флоу 2: Клик по карточке -> переход в админку заведения
UX:
- В списке карточек кнопка «Открыть админку». Переход в уже существующий интерфейс админки (тот же WebApp/бот-страница) в контексте выбранного shop_id.

Технически:
- Cуществующая админка поддерживает вход по параметру shop_id и проверяет роль super_admin для разрешения доступа вне владельца.


### Флоу 3: Редактирование как владелец
Объем действий (переиспользуем существующие endpoints):
- Детальный профиль партнера — PUT /v2/shop (см. api_shop.go: PutShop, service.ShopUpdate, rdb.ShopUpdate).
- Добавить блюдо — POST /v2/shop/food.
- Редактировать меню — PUT/DELETE /v2/shop/food.
- Отчет по заказам — существующий /v2/order/report (см. api_order.go / api_order_report.go).

- Суперадмин имеет те же права, что владелец, плюс может действовать для любого shop_id.

Ошибки:
- 403 — если роль не super_admin и не владелец.
- 400/500 — стандартно по существующей логике.

### Флоу 4: «Назад» к списку
UX: кнопка «Назад» в WebApp возвращает к списку, сброс дополнительного контекста не требуется (имперсонации нет).
Backend: изменений не требуется.

### Флоу 5: «Создать заведение»
UX:
- Форма создания: обязательные поля минимально — name; дополнительно (опционально) phone, city, address fields, photo, start_text.
- Заведение создаётся с owner_id=0.

API:
- POST /v2/shop (уже есть). Требует роль super_admin. При отсутствии обязательных полей — 400.

Результат:
- Новый shop попадает в список.

### Флоу 6: «Назначить группу (именную ссылку)»
UX:
- В карточке или внутри админки или в Детали партнера - кнопка «Назначить группу». Поле для ввода code (именной ссылки).

API (новое):
- PUT /v2/shops/{id}/group
  - body: { code: string }
  - 200 OK. Идемпотентно добавляет shop_id в shop_groups[code].
  - Валидация code: [a-z0-9-], длина 3..16, case-insensitive (нормализуем к lower).
  - Ошибки: 400 (валидация), 401/403 (роль), 409 (конкурентный конфликт, опционально retry), 500.

Реализация:
- rdb.PutShopOfOwner(ctx, code, shopID) — уже готово и добавляет shopID в массив для code.
- rdb.GetCodeByShopID — чтобы отобразить текущий code в UI.

Примечания:
- Одна группа может содержать несколько заведений.

## Роли и безопасность

Определение роли:
- Добавить роль super_admin на основе User.Source:
  - model.User.Role(): если u.Source == "super_admin" => "super_admin".

Доступ к endpoint’ам:
- Все новые суперадминские endpoints и UI доступны только при Role() == "super_admin".
- Существующие endpoints (редактирование shop/food, отчеты) разрешают доступ и владельцу, и супер-админу:
  - Проверка: если user.Role()=="super_admin" — разрешить для любого shop_id; иначе - только для owner_id.

Telegram WebApp авторизация:
- Получение JWT через /v2/jwt с initData Telegram; jwtGenerator уже есть (api_jwt.go).
- В JWT хранится userID; роль определяется на бекенде через userService+model.User.Role().
- Срок жизни токена - короткий, обновление по мере необходимости 

## Изменения БД

- Использовать существующие таблицы: shops, shop_addresses, shop_groups(code, shop_ids[]).
- Новые миграции не требуются для основной логики.


## Изменения сервисного слоя и API

Новые/расширенные endpoints:
- GET /v2/superadmin/shops — список карточек с поиском и фильтрами (role: super_admin).
- PUT /v2/shops/{id}/group — назначение именной ссылки (role: super_admin) — использует rdb.PutShopOfOwner.
- Опционально: расширить /v2/shop/all для поддержки фильтров, но предпочтительно отдельный endpoint под super_admin.

Проверки прав в существующих handlers:
- api_shop.go: GetAllShops - сейчас ограничен ролью "glavbuh"; оставить как есть; новая логика — отдельный endpoint.
- api_shop.go: PostShop/PutShop/food endpoints - добавить условие допуска super_admin для любых shop_id.

Связи с кодом:
- rdb/rdb_shop_qs.go — ShopGetAll (активные) и CRUD.
- rdb/rdb_shop_group_qs.go — PutShopOfOwner, GetShopsByCode, GetCodeByShopID.
- api/api_shop.go — handlers для shops/foods.
- api/api.go — AuthMiddleware и routing.
- model/user.go — Role() (добавить super_admin).
- telegram/* — кнопка открытия WebApp и доступность опций только для super_admin.

## Тест-план

Юнит-тесты:
- model.User.Role(): возвращает super_admin при Source=="super_admin".
- Право доступа: super_admin может вызывать новые endpoints и редактировать любой shop.
- Валидация code при назначении группы (регулярка и длина).

Интеграционные тесты (rdb):
- rdb.PutShopOfOwner: добавление shopID в code, идемпотентность, регистр кода (lower).
- rdb.GetCodeByShopID: корректный возврат code.

API/handlers:
- GET /v2/superadmin/shops — фильтры и поиск.
- PUT /v2/shops/{id}/group — успешное назначение и обработка ошибок.

E2E (WebApp):
- Открытие меню и списка; переход в админку; возврат; создание заведения; назначение группы.

Критерии PASS (acceptance):
- Суперадмин видит все карточки; поиск по названию и фильтр «С именной ссылкой» работают.
- Переход по карточке открывает существующую админку заведения с возможностью редактирования.
- Создание заведения через форму — запись появляется в списке.
- Назначение группы закрепляет code за заведением; повторный вызов идемпотентен; формат кода валиден.
- Обычный пользователь/владелец не видит супер-админский WebApp и не имеет доступа к новым endpoint’ам.



